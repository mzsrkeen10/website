---
title: "AGC021 B - Holes"
slug: "agc021b"
date: 2018-03-02T19:01:00+09:00
draft: false
categories: ["競プロ"]
tags: ["AtCoder", "計算幾何", "凸包"]
---

[問題](https://beta.atcoder.jp/contests/agc021/tasks/agc021_b)
<!--more-->
***

### 方針

問題文と制約を見ると、円の半径に対して穴の座標の絶対値が非常に小さいことが分かります。また、出力値は\\(10^{-5}\\)以下の誤差を含むことが許されています。
これらを踏まえサンプルを見てみると、  

- サンプル1の _「確率は 0.5 に非常に近い」_ という文言
- サンプル2の4つ目の穴が選ばれる確率が0であること

の2点に気が付きます。ました。

この2点より、確率はザックリとした値を求めればよいことが分かります。  
そして円の半径が非常に大きいことから、
\\(|x_i|,|y_i| \leq 10^6\\)の範囲にすぬけ君が置かれる確率は非常に小さく、
他の穴に囲まれているような穴(=凸包に含まれない穴)は確率を0として良さそうだということも分かります。

凸包上の穴についてはどうでしょうか。  
凸包上のある穴を\\(p\\)、その隣の穴を\\(q,r\\)とすると、
すぬけ君が\\(p\\)に落ちるのは、
\\(pq\\)の垂直二等分線と\\(qr\\)の垂直二等分線によって分けられた領域のうち、
\\(p\\)を含む領域に置かれたときです。
なので、円の面積に対するこの領域の面積の比率がそのまま答えになりますが、
円が非常に大きいため面積を求めることが出来ません。
そこで、面積の代わりに角度を用います。
つまり、\\(2\pi\\)に対する、垂直二等分線同士のなす角の比率が答えになります。
垂直二等分線同士のなす角の大きさは、\\(\angle qpr\\)を\\(\pi\\)から引いた値と等しくなるので、atan2()等を使って求めれば良いです。

以上をまとめると、

1. まず凸包を求めて、
1. 凸包上の隣り合う辺がなす角の大きさを求めて、
1. \\(2\pi\\)に対する割合を答えとする

となります。  
計算量は、凸包を求めるのにAndrew's Monotone Chainを用いれば\\(O(nlogn)\\)です。

***

#### \\(O(n^2logn)\\)解法

上記の解法をそのまま実装しても良いのですが、
幾何ライブラリを整備していないと凸包を求めるのに非常に手間がかかります。
しかし、もう少し考察を進めると実装量をぐんと減らすことが出来ます。

ある穴\\(p\\)を中心に、反時計回りに2つの穴\\(q,r\\)を選びます。  
この時、\\(\angle qpr\\)の最大値は、凸包内の穴では\\(\pi\\)未満となります。

![凸包内の点](/images/post/2018-03-02-agc012b/picture1.png)  
一方、凸包上の穴では、\\(\angle qpr \geq \pi\\)となるような\\(q,r\\)が存在します。  
![凸包上の点](/images/post/2018-03-02-agc012b/picture2.png)  

この性質を利用すれば、凸包を求めることなく解が求まります。  
具体的には、全ての穴に対して、以下の操作を行います。

1. 他の穴とのなす偏角を全て求めてソートしておく。偏角が最も小さいものについては、\\(+2\pi\\)したものも作っておく。
1. 隣り合う偏角の差の最大値\\(maxi\\)を求める。
1. \\(max(0, \frac{maxi-\pi}{2\pi})\\)が求める確率となる。

ソートを穴の数だけ行うので、計算量は\\(O(n^2logn)\\)です。

↓ソースコード
```C++
#include<bits/stdc++.h>
using namespace std;

const double pi = acos(-1);

int main(){
    int n;
    cin >> n;
    vector<double> x, y;
    for(int i=0;i<n;++i){
        double a, b;
        cin >> a >> b;
        x.push_back(a);
        y.push_back(b);
    }

    for(int i=0;i<n;++i){
        vector<double> agl;
        for(int j=0;j<n;++j)
            if(i != j)
                agl.push_back(atan2(y[j]-y[i], x[j]-x[i]));
        sort(agl.begin(), agl.end());
        agl.push_back(agl[0] + 2*pi);
        double maxi = 0;
        for(int j=1;j<agl.size();++j)
            maxi = max(maxi, agl[j] - agl[j-1] - pi);
        printf("%.10f\n", maxi/(2*pi));
    }

    return 0;
}
```

ちなみに、凸包を用いた解法のコードは[こちら](https://gist.github.com/mzsrkeen10/2d9b72915a4c8098b7582fb2bff7a429)にあります。  
コード長は\\(O(n^2logn)\\)解法の4倍になりました。。。

***

#### あとがき

コンテスト中は「凸包ライブラリ持ってねぇ〜」と唸ってました。  
考察って大事ですね。

***
